// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"graph/ent/post"
	"graph/ent/user"
	"sync"

	"github.com/facebook/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCity    = "City"
	TypeComment = "Comment"
	TypeCountry = "Country"
	TypeForum   = "Forum"
	TypePost    = "Post"
	TypeTag     = "Tag"
	TypeUser    = "User"
)

// CityMutation represents an operation that mutate the Cities
// nodes in the graph.
type CityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*City, error)
}

var _ ent.Mutation = (*CityMutation)(nil)

// cityOption allows to manage the mutation configuration using functional options.
type cityOption func(*CityMutation)

// newCityMutation creates new mutation for $n.Name.
func newCityMutation(c config, op Op, opts ...cityOption) *CityMutation {
	m := &CityMutation{
		config:        c,
		op:            op,
		typ:           TypeCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCityID sets the id field of the mutation.
func withCityID(id int) cityOption {
	return func(m *CityMutation) {
		var (
			err   error
			once  sync.Once
			value *City
		)
		m.oldValue = func(ctx context.Context) (*City, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().City.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCity sets the old City of the mutation.
func withCity(node *City) cityOption {
	return func(m *CityMutation) {
		m.oldValue = func(context.Context) (*City, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *CityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (City).
func (m *CityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown City field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown City field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown City numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown City nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown City field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CityMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CityMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CityMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CityMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown City unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CityMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown City edge %s", name)
}

// CommentMutation represents an operation that mutate the Comments
// nodes in the graph.
type CommentMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Comment, error)
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows to manage the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for $n.Name.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the id field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Comment edge %s", name)
}

// CountryMutation represents an operation that mutate the Countries
// nodes in the graph.
type CountryMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Country, error)
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows to manage the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for $n.Name.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the id field of the mutation.
func withCountryID(id int) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CountryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Country edge %s", name)
}

// ForumMutation represents an operation that mutate the Forums
// nodes in the graph.
type ForumMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Forum, error)
}

var _ ent.Mutation = (*ForumMutation)(nil)

// forumOption allows to manage the mutation configuration using functional options.
type forumOption func(*ForumMutation)

// newForumMutation creates new mutation for $n.Name.
func newForumMutation(c config, op Op, opts ...forumOption) *ForumMutation {
	m := &ForumMutation{
		config:        c,
		op:            op,
		typ:           TypeForum,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withForumID sets the id field of the mutation.
func withForumID(id int) forumOption {
	return func(m *ForumMutation) {
		var (
			err   error
			once  sync.Once
			value *Forum
		)
		m.oldValue = func(ctx context.Context) (*Forum, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Forum.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withForum sets the old Forum of the mutation.
func withForum(node *Forum) forumOption {
	return func(m *ForumMutation) {
		m.oldValue = func(context.Context) (*Forum, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ForumMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ForumMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ForumMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *ForumMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Forum).
func (m *ForumMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ForumMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ForumMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ForumMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Forum field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ForumMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Forum field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ForumMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ForumMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ForumMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Forum numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ForumMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ForumMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ForumMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Forum nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ForumMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Forum field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ForumMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ForumMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ForumMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ForumMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ForumMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ForumMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ForumMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Forum unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ForumMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Forum edge %s", name)
}

// PostMutation represents an operation that mutate the Posts
// nodes in the graph.
type PostMutation struct {
	config
	op            Op
	typ           string
	id            *int
	content       *string
	clearedFields map[string]struct{}
	likes         map[int]struct{}
	removedlikes  map[int]struct{}
	clearedlikes  bool
	done          bool
	oldValue      func(context.Context) (*Post, error)
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows to manage the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for $n.Name.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the id field of the mutation.
func withPostID(id int) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetContent sets the content field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the content value in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old content value of the Post.
// If the Post object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent reset all changes of the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// AddLikeIDs adds the likes edge to User by ids.
func (m *PostMutation) AddLikeIDs(ids ...int) {
	if m.likes == nil {
		m.likes = make(map[int]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the likes edge to User.
func (m *PostMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared returns if the edge likes was cleared.
func (m *PostMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the likes edge to User by ids.
func (m *PostMutation) RemoveLikeIDs(ids ...int) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed ids of likes.
func (m *PostMutation) RemovedLikesIDs() (ids []int) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the likes ids in the mutation.
func (m *PostMutation) LikesIDs() (ids []int) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes reset all changes of the "likes" edge.
func (m *PostMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.likes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlikes != nil {
		edges = append(edges, post.EdgeLikes)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlikes {
		edges = append(edges, post.EdgeLikes)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeLikes:
		return m.clearedlikes
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeLikes:
		m.ResetLikes()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// TagMutation represents an operation that mutate the Tags
// nodes in the graph.
type TagMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Tag, error)
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows to manage the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for $n.Name.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the id field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *int
	age               *int
	addage            *int
	name              *string
	clearedFields     map[string]struct{}
	followers         map[int]struct{}
	removedfollowers  map[int]struct{}
	clearedfollowers  bool
	following         map[int]struct{}
	removedfollowing  map[int]struct{}
	clearedfollowing  bool
	requesters        map[int]struct{}
	removedrequesters map[int]struct{}
	clearedrequesters bool
	requesting        map[int]struct{}
	removedrequesting map[int]struct{}
	clearedrequesting bool
	friend            map[int]struct{}
	removedfriend     map[int]struct{}
	clearedfriend     bool
	likes             map[int]struct{}
	removedlikes      map[int]struct{}
	clearedlikes      bool
	done              bool
	oldValue          func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAge sets the age field.
func (m *UserMutation) SetAge(i int) {
	m.age = &i
	m.addage = nil
}

// Age returns the age value in the mutation.
func (m *UserMutation) Age() (r int, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old age value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to age.
func (m *UserMutation) AddAge(i int) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the age field in this mutation.
func (m *UserMutation) AddedAge() (r int, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ClearAge clears the value of age.
func (m *UserMutation) ClearAge() {
	m.age = nil
	m.addage = nil
	m.clearedFields[user.FieldAge] = struct{}{}
}

// AgeCleared returns if the field age was cleared in this mutation.
func (m *UserMutation) AgeCleared() bool {
	_, ok := m.clearedFields[user.FieldAge]
	return ok
}

// ResetAge reset all changes of the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
	delete(m.clearedFields, user.FieldAge)
}

// SetName sets the name field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// AddFollowerIDs adds the followers edge to User by ids.
func (m *UserMutation) AddFollowerIDs(ids ...int) {
	if m.followers == nil {
		m.followers = make(map[int]struct{})
	}
	for i := range ids {
		m.followers[ids[i]] = struct{}{}
	}
}

// ClearFollowers clears the followers edge to User.
func (m *UserMutation) ClearFollowers() {
	m.clearedfollowers = true
}

// FollowersCleared returns if the edge followers was cleared.
func (m *UserMutation) FollowersCleared() bool {
	return m.clearedfollowers
}

// RemoveFollowerIDs removes the followers edge to User by ids.
func (m *UserMutation) RemoveFollowerIDs(ids ...int) {
	if m.removedfollowers == nil {
		m.removedfollowers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfollowers[ids[i]] = struct{}{}
	}
}

// RemovedFollowers returns the removed ids of followers.
func (m *UserMutation) RemovedFollowersIDs() (ids []int) {
	for id := range m.removedfollowers {
		ids = append(ids, id)
	}
	return
}

// FollowersIDs returns the followers ids in the mutation.
func (m *UserMutation) FollowersIDs() (ids []int) {
	for id := range m.followers {
		ids = append(ids, id)
	}
	return
}

// ResetFollowers reset all changes of the "followers" edge.
func (m *UserMutation) ResetFollowers() {
	m.followers = nil
	m.clearedfollowers = false
	m.removedfollowers = nil
}

// AddFollowingIDs adds the following edge to User by ids.
func (m *UserMutation) AddFollowingIDs(ids ...int) {
	if m.following == nil {
		m.following = make(map[int]struct{})
	}
	for i := range ids {
		m.following[ids[i]] = struct{}{}
	}
}

// ClearFollowing clears the following edge to User.
func (m *UserMutation) ClearFollowing() {
	m.clearedfollowing = true
}

// FollowingCleared returns if the edge following was cleared.
func (m *UserMutation) FollowingCleared() bool {
	return m.clearedfollowing
}

// RemoveFollowingIDs removes the following edge to User by ids.
func (m *UserMutation) RemoveFollowingIDs(ids ...int) {
	if m.removedfollowing == nil {
		m.removedfollowing = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfollowing[ids[i]] = struct{}{}
	}
}

// RemovedFollowing returns the removed ids of following.
func (m *UserMutation) RemovedFollowingIDs() (ids []int) {
	for id := range m.removedfollowing {
		ids = append(ids, id)
	}
	return
}

// FollowingIDs returns the following ids in the mutation.
func (m *UserMutation) FollowingIDs() (ids []int) {
	for id := range m.following {
		ids = append(ids, id)
	}
	return
}

// ResetFollowing reset all changes of the "following" edge.
func (m *UserMutation) ResetFollowing() {
	m.following = nil
	m.clearedfollowing = false
	m.removedfollowing = nil
}

// AddRequesterIDs adds the requesters edge to User by ids.
func (m *UserMutation) AddRequesterIDs(ids ...int) {
	if m.requesters == nil {
		m.requesters = make(map[int]struct{})
	}
	for i := range ids {
		m.requesters[ids[i]] = struct{}{}
	}
}

// ClearRequesters clears the requesters edge to User.
func (m *UserMutation) ClearRequesters() {
	m.clearedrequesters = true
}

// RequestersCleared returns if the edge requesters was cleared.
func (m *UserMutation) RequestersCleared() bool {
	return m.clearedrequesters
}

// RemoveRequesterIDs removes the requesters edge to User by ids.
func (m *UserMutation) RemoveRequesterIDs(ids ...int) {
	if m.removedrequesters == nil {
		m.removedrequesters = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrequesters[ids[i]] = struct{}{}
	}
}

// RemovedRequesters returns the removed ids of requesters.
func (m *UserMutation) RemovedRequestersIDs() (ids []int) {
	for id := range m.removedrequesters {
		ids = append(ids, id)
	}
	return
}

// RequestersIDs returns the requesters ids in the mutation.
func (m *UserMutation) RequestersIDs() (ids []int) {
	for id := range m.requesters {
		ids = append(ids, id)
	}
	return
}

// ResetRequesters reset all changes of the "requesters" edge.
func (m *UserMutation) ResetRequesters() {
	m.requesters = nil
	m.clearedrequesters = false
	m.removedrequesters = nil
}

// AddRequestingIDs adds the requesting edge to User by ids.
func (m *UserMutation) AddRequestingIDs(ids ...int) {
	if m.requesting == nil {
		m.requesting = make(map[int]struct{})
	}
	for i := range ids {
		m.requesting[ids[i]] = struct{}{}
	}
}

// ClearRequesting clears the requesting edge to User.
func (m *UserMutation) ClearRequesting() {
	m.clearedrequesting = true
}

// RequestingCleared returns if the edge requesting was cleared.
func (m *UserMutation) RequestingCleared() bool {
	return m.clearedrequesting
}

// RemoveRequestingIDs removes the requesting edge to User by ids.
func (m *UserMutation) RemoveRequestingIDs(ids ...int) {
	if m.removedrequesting == nil {
		m.removedrequesting = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrequesting[ids[i]] = struct{}{}
	}
}

// RemovedRequesting returns the removed ids of requesting.
func (m *UserMutation) RemovedRequestingIDs() (ids []int) {
	for id := range m.removedrequesting {
		ids = append(ids, id)
	}
	return
}

// RequestingIDs returns the requesting ids in the mutation.
func (m *UserMutation) RequestingIDs() (ids []int) {
	for id := range m.requesting {
		ids = append(ids, id)
	}
	return
}

// ResetRequesting reset all changes of the "requesting" edge.
func (m *UserMutation) ResetRequesting() {
	m.requesting = nil
	m.clearedrequesting = false
	m.removedrequesting = nil
}

// AddFriendIDs adds the friend edge to User by ids.
func (m *UserMutation) AddFriendIDs(ids ...int) {
	if m.friend == nil {
		m.friend = make(map[int]struct{})
	}
	for i := range ids {
		m.friend[ids[i]] = struct{}{}
	}
}

// ClearFriend clears the friend edge to User.
func (m *UserMutation) ClearFriend() {
	m.clearedfriend = true
}

// FriendCleared returns if the edge friend was cleared.
func (m *UserMutation) FriendCleared() bool {
	return m.clearedfriend
}

// RemoveFriendIDs removes the friend edge to User by ids.
func (m *UserMutation) RemoveFriendIDs(ids ...int) {
	if m.removedfriend == nil {
		m.removedfriend = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfriend[ids[i]] = struct{}{}
	}
}

// RemovedFriend returns the removed ids of friend.
func (m *UserMutation) RemovedFriendIDs() (ids []int) {
	for id := range m.removedfriend {
		ids = append(ids, id)
	}
	return
}

// FriendIDs returns the friend ids in the mutation.
func (m *UserMutation) FriendIDs() (ids []int) {
	for id := range m.friend {
		ids = append(ids, id)
	}
	return
}

// ResetFriend reset all changes of the "friend" edge.
func (m *UserMutation) ResetFriend() {
	m.friend = nil
	m.clearedfriend = false
	m.removedfriend = nil
}

// AddLikeIDs adds the likes edge to Post by ids.
func (m *UserMutation) AddLikeIDs(ids ...int) {
	if m.likes == nil {
		m.likes = make(map[int]struct{})
	}
	for i := range ids {
		m.likes[ids[i]] = struct{}{}
	}
}

// ClearLikes clears the likes edge to Post.
func (m *UserMutation) ClearLikes() {
	m.clearedlikes = true
}

// LikesCleared returns if the edge likes was cleared.
func (m *UserMutation) LikesCleared() bool {
	return m.clearedlikes
}

// RemoveLikeIDs removes the likes edge to Post by ids.
func (m *UserMutation) RemoveLikeIDs(ids ...int) {
	if m.removedlikes == nil {
		m.removedlikes = make(map[int]struct{})
	}
	for i := range ids {
		m.removedlikes[ids[i]] = struct{}{}
	}
}

// RemovedLikes returns the removed ids of likes.
func (m *UserMutation) RemovedLikesIDs() (ids []int) {
	for id := range m.removedlikes {
		ids = append(ids, id)
	}
	return
}

// LikesIDs returns the likes ids in the mutation.
func (m *UserMutation) LikesIDs() (ids []int) {
	for id := range m.likes {
		ids = append(ids, id)
	}
	return
}

// ResetLikes reset all changes of the "likes" edge.
func (m *UserMutation) ResetLikes() {
	m.likes = nil
	m.clearedlikes = false
	m.removedlikes = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.Age()
	case user.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldAge) {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldAge:
		m.ClearAge()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.followers != nil {
		edges = append(edges, user.EdgeFollowers)
	}
	if m.following != nil {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.requesters != nil {
		edges = append(edges, user.EdgeRequesters)
	}
	if m.requesting != nil {
		edges = append(edges, user.EdgeRequesting)
	}
	if m.friend != nil {
		edges = append(edges, user.EdgeFriend)
	}
	if m.likes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.followers))
		for id := range m.followers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.following))
		for id := range m.following {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequesters:
		ids := make([]ent.Value, 0, len(m.requesters))
		for id := range m.requesters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequesting:
		ids := make([]ent.Value, 0, len(m.requesting))
		for id := range m.requesting {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriend:
		ids := make([]ent.Value, 0, len(m.friend))
		for id := range m.friend {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.likes))
		for id := range m.likes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedfollowers != nil {
		edges = append(edges, user.EdgeFollowers)
	}
	if m.removedfollowing != nil {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.removedrequesters != nil {
		edges = append(edges, user.EdgeRequesters)
	}
	if m.removedrequesting != nil {
		edges = append(edges, user.EdgeRequesting)
	}
	if m.removedfriend != nil {
		edges = append(edges, user.EdgeFriend)
	}
	if m.removedlikes != nil {
		edges = append(edges, user.EdgeLikes)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeFollowers:
		ids := make([]ent.Value, 0, len(m.removedfollowers))
		for id := range m.removedfollowers {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFollowing:
		ids := make([]ent.Value, 0, len(m.removedfollowing))
		for id := range m.removedfollowing {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequesters:
		ids := make([]ent.Value, 0, len(m.removedrequesters))
		for id := range m.removedrequesters {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRequesting:
		ids := make([]ent.Value, 0, len(m.removedrequesting))
		for id := range m.removedrequesting {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeFriend:
		ids := make([]ent.Value, 0, len(m.removedfriend))
		for id := range m.removedfriend {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeLikes:
		ids := make([]ent.Value, 0, len(m.removedlikes))
		for id := range m.removedlikes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedfollowers {
		edges = append(edges, user.EdgeFollowers)
	}
	if m.clearedfollowing {
		edges = append(edges, user.EdgeFollowing)
	}
	if m.clearedrequesters {
		edges = append(edges, user.EdgeRequesters)
	}
	if m.clearedrequesting {
		edges = append(edges, user.EdgeRequesting)
	}
	if m.clearedfriend {
		edges = append(edges, user.EdgeFriend)
	}
	if m.clearedlikes {
		edges = append(edges, user.EdgeLikes)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeFollowers:
		return m.clearedfollowers
	case user.EdgeFollowing:
		return m.clearedfollowing
	case user.EdgeRequesters:
		return m.clearedrequesters
	case user.EdgeRequesting:
		return m.clearedrequesting
	case user.EdgeFriend:
		return m.clearedfriend
	case user.EdgeLikes:
		return m.clearedlikes
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeFollowers:
		m.ResetFollowers()
		return nil
	case user.EdgeFollowing:
		m.ResetFollowing()
		return nil
	case user.EdgeRequesters:
		m.ResetRequesters()
		return nil
	case user.EdgeRequesting:
		m.ResetRequesting()
		return nil
	case user.EdgeFriend:
		m.ResetFriend()
		return nil
	case user.EdgeLikes:
		m.ResetLikes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
